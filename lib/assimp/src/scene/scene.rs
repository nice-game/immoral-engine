use ffi::*;

// Import all types
use super::animation::*;
use super::camera::*;
use super::light::*;
use super::material::*;
use super::mesh::*;
use super::node::*;
use super::texture::*;

define_type! {
    /// The `Scene` type is the root container for all imported scene data.
    struct Scene(&AiScene)
}

impl<'a> Scene<'a> {
    /// Returns true if the imported scene is not complete.
    pub fn is_incomplete(&self) -> bool {
        self.flags.contains(AI_SCENE_FLAGS_INCOMPLETE)
    }

    /// Returns true if the imported scene was successfully validated by the
    /// `validate_data_structure` post-process step.
    pub fn is_validated(&self) -> bool {
        self.flags.contains(AI_SCENE_FLAGS_VALIDATED)
    }

    /// Returns true if any warnings were generated by the `validate_data_structure`
    /// post-process step. The details of the warnings are written to the output log.
    pub fn has_validation_warning(&self) -> bool {
        self.flags.contains(AI_SCENE_FLAGS_VALIDATION_WARNING)
    }

    /// Returns true if the `join_identical_vertices` post-process step was run.
    pub fn is_non_verbose_format(&self) -> bool {
        self.flags.contains(AI_SCENE_FLAGS_NON_VERBOSE_FORMAT)
    }

    /// Returns true if the imported mesh contained height-map terrain data.
    pub fn is_terrain(&self) -> bool {
        self.flags.contains(AI_SCENE_FLAGS_TERRAIN)
    }

    /// Returns the root node of the scene hierarchy
    pub fn root_node(&self) -> Node {
        Node::from_raw(self.root_node)
    }

    /// Returns the number of meshes in the scene.
    pub fn num_meshes(&self) -> u32 {
        self.num_meshes
    }

    /// Returns an iterator over all the meshes in the scene.
    pub fn mesh_iter(&self) -> MeshIter {
        MeshIter::new(self.meshes as *const *const AiMesh,
                      self.num_meshes as usize)
    }

    /// Return an individual mesh from the scene.
    pub fn mesh(&self, id: usize) -> Option<Mesh> {
        if id < self.num_meshes as usize {
            unsafe { Some(Mesh::from_raw(*(self.meshes.offset(id as isize)))) }
        } else {
            None
        }
    }

    /// Returns the number of materials in the scene.
    pub fn num_materials(&self) -> u32 {
        self.num_materials
    }

    /// Returns an iterator over all the materials in the scene.
    pub fn material_iter(&self) -> MaterialIter {
        MaterialIter::new(self.materials as *const *const AiMaterial,
                          self.num_materials as usize)
    }

    /// Returns the number of animations in the scene.
    pub fn num_animations(&self) -> u32 {
        self.num_animations
    }

    /// Returns an iterator over all the animations in the scene.
    pub fn animation_iter(&self) -> AnimationIter {
        AnimationIter::new(self.animations as *const *const AiAnimation,
                           self.num_animations as usize)
    }

    /// Return an individual animation from the scene.
    pub fn animation(&self, id: usize) -> Option<Animation> {
        if id < self.num_animations as usize {
            unsafe { Some(Animation::from_raw(*(self.animations.offset(id as isize)))) }
        } else {
            None
        }
    }

    /// Returns the number of animations in the scene.
    pub fn num_textures(&self) -> u32 {
        self.num_textures
    }

    /// Returns an iterator over all the textures in the scene.
    pub fn texture_iter(&self) -> TextureIter {
        TextureIter::new(self.textures as *const *const AiTexture,
                         self.num_textures as usize)
    }

    /// Returns the number of lights in the scene.
    pub fn num_lights(&self) -> u32 {
        self.num_lights
    }

    /// Returns an iterator over all the lights in the scene.
    pub fn light_iter(&self) -> LightIter {
        LightIter::new(self.lights as *const *const AiLight,
                       self.num_lights as usize)
    }

    /// Returns the number of cameras in the scene.
    pub fn num_cameras(&self) -> u32 {
        self.num_cameras
    }

    /// Returns an iterator over all the cameras in the scene.
    pub fn camera_iter(&self) -> CameraIter {
        CameraIter::new(self.cameras as *const *const AiCamera,
                        self.num_cameras as usize)
    }
}

// Drop implementation for a scene owned by Assimp.
// Scenes returned by aiImportFile* methods must be freed with aiReleaseImport.
impl<'a> Drop for Scene<'a> {
    fn drop(&mut self) {
        unsafe { aiReleaseImport(self.0); }
    }
}
